import {HAPServerConnection, HAPServerConnectionEvents} from "./HAPServer";
import {CharacteristicType} from "./definitions";
import * as tlv from './utils/tlv';
import {DataStreamProxy} from "./datastream/DataStreamProxy";
import {
    CharacteristicFilterConstructor,
    CharacteristicFilterControlPoint,
    CharacteristicFilterR
} from "./filters/CharacteristicFilter";
import {ServiceFilter} from "./filters/ServiceFilter";
import {
    DataStream,
    DataStreamStatus,
    SessionCommandType,
    SetupDataStreamSessionTypes,
    SetupDataStreamWriteResponseTypes,
    TransportSessionConfiguration,
    TransportType
} from "./datastream";
import {HAPClientConnection} from "./HAPClient";
import {HAPProxy} from "./HAPProxy";

/**
 * Service "Protocol Information"
 */

export class AccessoryInformationServiceNameCharacteristicFilter extends CharacteristicFilterR<string> {

    async filterRead(connection: HAPServerConnection, clientConnection: HAPClientConnection, readValue: string): Promise<string> {
        return this.context.server.accessoryInfo.displayName; // override accessory name with the proxy server name
    }

}

export class AccessoryInformationServiceFilter extends ServiceFilter {

    characteristicFilterDefinitions: Record<string, CharacteristicFilterConstructor<any>> = {
        [CharacteristicType.NAME]: AccessoryInformationServiceNameCharacteristicFilter,
    }

}

// TODO hap version service (=> warning on incompatible version)

/**
 * Service "DataStreamManagement"
 */

export class DataStreamTransportManagementServiceSetupDataStreamTransportCharacteristicFilter extends CharacteristicFilterControlPoint<string> {

    private dataStreamProxy: DataStreamProxy = new DataStreamProxy();


    constructor(context: HAPProxy, parent: ServiceFilter, iid: number) {
        super(context, parent, iid);
    }

    connectionContext: Record<string, {
        lastResponse: string,

        controllerKeySalt: Buffer, // salt generated by the HomeKit Home Hub
        proxyControllerKeySalt: Buffer, // salt which we generate for communication with the accessory
    }> = {};

    async filterRead(serverConnection: HAPServerConnection, clientConnection: HAPClientConnection, readValue: string): Promise<string> {
        const context = this.connectionContext[serverConnection.sessionID];
        return context? context.lastResponse: "";
    }

    async filterWrite(serverConnection: HAPServerConnection, clientConnection: HAPClientConnection, writtenValue: string): Promise<string> {
        let context = this.connectionContext[serverConnection.sessionID];
        if (!context) {
            context = {
                lastResponse: "",
                controllerKeySalt: Buffer.alloc(0),
                proxyControllerKeySalt: Buffer.alloc(0),
            };
            this.connectionContext[serverConnection.sessionID] = context;

            // make sure we cleanup our stuff
            serverConnection.on(HAPServerConnectionEvents.DISCONNECTED, () => delete this.connectionContext[serverConnection.sessionID]);
        }

        const objects = tlv.decode(Buffer.from(writtenValue, "base64"));

        const sessionCommandType = objects[SetupDataStreamSessionTypes.SESSION_COMMAND_TYPE].readUInt8(0);
        const transportType = objects[SetupDataStreamSessionTypes.TRANSPORT_TYPE].readUInt8(0);
        // save the salt used for communication with the HomeKit controller device
        context.controllerKeySalt = objects[SetupDataStreamSessionTypes.CONTROLLER_KEY_SALT];

        if (sessionCommandType === SessionCommandType.START_SESSION) {
            if (transportType !== TransportType.HOMEKIT_DATA_STREAM) {
                return writtenValue;
            }

            // generate the salt used for the communication with the accessory
            context.proxyControllerKeySalt = this.dataStreamProxy.generateKeySalt();

            // create our "fake" request to setup the HDS connection with the accessory
            const request = tlv.encode(
                SetupDataStreamSessionTypes.SESSION_COMMAND_TYPE, SessionCommandType.START_SESSION,
                SetupDataStreamSessionTypes.TRANSPORT_TYPE, TransportType.HOMEKIT_DATA_STREAM,
                SetupDataStreamSessionTypes.CONTROLLER_KEY_SALT, context.proxyControllerKeySalt,
            );

            return request.toString("base64");
        } else {
            return writtenValue;
        }
    }

    async filterWriteResponse(serverConnection: HAPServerConnection, clientConnection: HAPClientConnection, writeResponseValue: string): Promise<string> {
        const context = this.connectionContext[serverConnection.sessionID];
        if (!context) {
            return "";
        }

        const objects = tlv.decode(Buffer.from(writeResponseValue, "base64"));
        const status = objects[SetupDataStreamWriteResponseTypes.STATUS].readUInt8(0);
        if (status !== DataStreamStatus.SUCCESS) {
            console.log("proxied accessory returned non successful status " + status); // TODO remove
            return writeResponseValue; // just forward non successful setup response
        }

        const sessionParametersData = objects[SetupDataStreamWriteResponseTypes.TRANSPORT_TYPE_SESSION_PARAMETERS];
        const accessoryKeySalt = objects[SetupDataStreamWriteResponseTypes.ACCESSORY_KEY_SALT];

        const sessionParametersTlv = tlv.decode(sessionParametersData);
        const port = sessionParametersTlv[TransportSessionConfiguration.TCP_LISTENING_PORT].readUInt16LE(0);

        const salt = Buffer.concat([context.proxyControllerKeySalt, accessoryKeySalt]);

        return this.dataStreamProxy.setupClient(clientConnection, this.context.client.deviceInfo!.host, port, salt)
            .then(clientConnection => this.dataStreamProxy.setupController(serverConnection, context.controllerKeySalt, clientConnection))
            .then(preparedSession => {
                const listeningPort = tlv.encode(TransportSessionConfiguration.TCP_LISTENING_PORT, tlv.writeUInt16(preparedSession.port!));

                let response: Buffer = Buffer.concat([
                    tlv.encode(SetupDataStreamWriteResponseTypes.STATUS, DataStreamStatus.SUCCESS),
                    tlv.encode(SetupDataStreamWriteResponseTypes.TRANSPORT_TYPE_SESSION_PARAMETERS, listeningPort)
                ]);
                context.lastResponse = response.toString("base64"); // save last response without accessory key salt

                response = Buffer.concat([
                    response,
                    tlv.encode(SetupDataStreamWriteResponseTypes.ACCESSORY_KEY_SALT, preparedSession.accessoryKeySalt)
                ]);

                // console.log("Returning response to controller!"); // TODO message

                return response.toString("base64");
            }).catch(reason => {
                console.log("Could not create hds client: " + reason); // TODO message
                return tlv.encode(SetupDataStreamWriteResponseTypes.STATUS, DataStreamStatus.GENERIC_ERROR).toString('base64');
            })
    }

}

export class DataStreamTransportManagementServiceVersionCharacteristic extends CharacteristicFilterR<string> {

    async filterRead(serverConnection: HAPServerConnection, clientConnection: HAPClientConnection, readValue: string): Promise<string> {
        if (readValue !== DataStream.VERSION) {
            console.log("WARNING! Data Stream endpoint of proxied accessory is not supported by hap-proxy!");
        }

        return readValue;
    }

}

export class DataStreamTransportManagementServiceFilter extends ServiceFilter {

    constructor(context: HAPProxy, aid: number, iid: number) {
        super(context, aid, iid);
    }

    characteristicFilterDefinitions: Record<string, CharacteristicFilterConstructor<any>> = {
        [CharacteristicType.SETUP_DATA_STREAM_TRANSPORT]: DataStreamTransportManagementServiceSetupDataStreamTransportCharacteristicFilter,
        [CharacteristicType.VERSION]: DataStreamTransportManagementServiceVersionCharacteristic,
    }

}


// TODO support RTP proxy (?)
